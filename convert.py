#!/usr/bin/env python3

# Copyright 2024, Ingo BreÃŸler (ingo.bressler@bam.de)
#
# Use of this source code is governed by the BSD-3-Clause
# license that can be found in the LICENSE file or at
# https://opensource.org/licenses/BSD-3-clause.

import argparse
import json
import re
from itertools import pairwise
from os import environ
from pathlib import Path
from pprint import pprint
from typing import List


def configureParser() -> argparse.ArgumentParser:

    def verifyFileExists(arg):
        if not arg:  # nothing specified.
            return None
        filepath = Path(arg).absolute()
        if not filepath.is_file():
            raise ValueError
        return filepath

    def verifyDirExists(arg):
        if not arg:  # nothing specified.
            return None
        filepath = Path(arg).absolute()
        if not filepath.is_dir():
            raise ValueError
        return filepath

    def needsAddressesAliases(parser):
        parser.add_argument(
            "-a",
            "--addressesAliases",
            type=verifyFileExists,
            default=environ.get("ADDRESSES_ALIASES", ""),
            metavar="<file path>",
            required=True,
            help=("""
                A markdown formatted file containing the motor device names and aliases on each
                serial network address and port.
                Read from environment variable ADDRESSES_ALIASES if not specified on command line.
            """),
        )
    def needsConfigAdm(parser):
        parser.add_argument(
            "-c",
            "--configAdm",
            type=verifyFileExists,
            default=environ.get("CONFIG_ADM", ""),
            metavar="<file path>",
            required=True,
            help=("""
                A path to the file containing the output of the configAdm command in SPEC.
                Read from environment variable CONFIG_ADM if not specified on command line.
            """),
        )
    def needsLimits(parser):
        parser.add_argument(
            "-l",
            "--limits",
            type=verifyFileExists,
            default=environ.get("LIMITS", ""),
            metavar="<file path>",
            required=True,
            help=("""
                A file generated by SPEC containing the limits of each motor.
                Read from environment variable DACHS_SOL1 if not specified on command line.
                Use the following SPEC code:
                for (i = 0; i < MOTORS; i++) { printf("Motor %%s: address %%s; lower_limit %%g; upper_limit %%g; offset %%g\n", motor_name(i), motor_par(i, "device_id"), get_lim(i, -1), get_lim(i, 1), motor_par(i, "offset")); }
            """),
        )
    def needsImsPath(parser):
        parser.add_argument(
            "-p",
            "--imsPath",
            type=verifyDirExists,
            default=environ.get("IMS_PATH", ""),
            metavar="<file path>",
            required=True,
            help=("""
                Path to the EPICS motor module 'motorIms'.
                The IOC binary is expected in the subdirectory 'iocs/imsIOC/bin'.
                Read from environment variable IMS_PATH if not specified on command line.
            """),
        )

    # process input arguments
    parser = argparse.ArgumentParser(
        prog=__package__,
        description="""
            Converts a SPEC IMS/Schneider MDrive motor config from `config_adm`
            to a motorIMS EPICS module substitutions file.
            (Released under a MIT license.)
            """,
    )
    subparsers = parser.add_subparsers(title="Available sub-commands", required=True)
    generateParser = subparsers.add_parser("generate", help="Generate IOC scripts.")
    generateParser.set_defaults(mode="generate")
    needsAddressesAliases(generateParser)
    needsConfigAdm(generateParser)
    needsLimits(generateParser)
    needsImsPath(generateParser)
    emParser = subparsers.add_parser("echomode", help="Set Echo Mode (EM) on a given port.")
    emParser.set_defaults(mode="echomode")
    emParser.add_argument(
        "port", type=str, help="Port number or name to toggle connected devices on."
    )
    emParser.add_argument("value", type=int, help="Mode to set.", choices=[1, 2])
    needsAddressesAliases(emParser)
    return parser


def convertValue(value):
    try:
        value = int(value, 0)
    except ValueError:
        try:
            value = float(value)
        except ValueError:
            pass
    except TypeError:
        # print(">  in:", value, type(value))
        pass
    # print("> out:", value, type(value))
    return value


def readAliasesAndAddresses(filename: Path):
    # print(filename)
    infn = Path(filename)
    allwords = [line.split() for line in infn.read_text().splitlines()]
    # remove empty lines (word lists)
    allwords = [words for words in allwords if words]
    # print(allwords)
    # find indices where each section begins, starts with #
    idx = [idx for idx, words in enumerate(allwords) if words[0].startswith("#")]
    sections = [allwords[idx[i] : idx[i + 1]] for i in range(len(idx) - 1)]
    sections += [allwords[idx[-1] :]]
    # process each section
    deviceNames = dict()
    addresses = dict()
    for section in sections:
        # print(section)
        address = [word for word in section[0] if ":" in word]
        address = address[0] if len(address) else None
        # print(address)
        aliases = {words[2]: words[1].strip('"') for words in section if words[0].startswith("-")}
        deviceNames.update(aliases)
        # print(aliases)
        addresses.update({alias: address for alias in aliases})
    return deviceNames, addresses


def readLimits(filename: Path):
    infn = Path(filename)
    # get lines and separating from motor names
    allwords = [line.split(": ") for line in infn.read_text().splitlines()]
    # splitting key/value fields following the motor names
    allwords = [
        [line[0]] + line[1].split("; ")
        for line in allwords
        if line and len(line) > 1 and line[0].startswith("Motor")
    ]
    # return the key/value dicts indexed by the motor names only
    return {
        " ".join(line[0].split()[1:]): dict(item.split() for item in line[1:]) for line in allwords
    }


def convertValues(motorList: List[dict]):
    """Converts value strings to numbers (int or float) in-place if possible."""
    for i, motor in enumerate(motorList):
        # print("> motor:")
        # pprint(motor)
        for key, value in motor.items():
            motorList[i][key] = convertValue(value)


def motorsFromSPEC(
    filename: Path, deviceNames: dict, addresses: dict, limits: dict, filterCntrl=None
):
    """Parses config_adm output from SPEC to a list of dicts of key/value pairs of configuration
    settings for each MDRIVE motor.
    *filename*: Text file of `config_adm` output."""
    infn = Path(filename)
    lines = infn.read_text().splitlines()
    # get the motor definitions only
    fieldNames = [line[2:] for line in lines if line.startswith("# Motor")][0].split()
    # print(f"{fieldNames=}")
    # identify consecutive lines of each motor
    motorIndices = [idx for idx, line in enumerate(lines) if re.match(r"MOT[0-9]{3}", line)]
    motors = []
    for start, end in pairwise(motorIndices):
        # first line should contain the common fields
        fieldValues = lines[start].replace("=", "").split(maxsplit=len(fieldNames) - 1)
        # print(lines[start:end], len(fieldNames), len(fieldValues))
        motor = dict(zip(fieldNames, fieldValues))
        # print(f"{motor=}")
        # extract additional parameters needed
        for line in lines[start + 1 : end]:
            name, value = line.split(" = ")
            name, value = name.split(":")[-1], value.strip()
            motor.update({name: value})
        if "name" in motor:
            motor["devName"] = deviceNames.get(motor["name"], "")
            motor["address"] = addresses.get(motor["name"], "")
            try:
                for key in ("lower_limit", "upper_limit", "offset"):
                    motor[key] = convertValue(limits[motor["name"]][key])
            except KeyError:
                print("motor", motor["name"], limits[motor["name"]])

        if filterCntrl and motor["cntrl"].startswith(filterCntrl):
            motors.append(motor)
    return motors


def substitutions(motors):
    fieldWidth = {
        "P": 4,
        "N": 3,
        "M": 7,
        "DTYP": 11,
        "PORT": 4,
        "DESC": 10,
        "ADDR": 4,
        "EGU": 3,
        "DIR": 3,
        "VELO": 6,
        "VBAS": 12,
        "ACCL": 6,
        "BDST": 6,
        "BVEL": 6,
        "BACC": 6,
        "DLLM": 8,
        "DHLM": 8,
        "MRES": 12,
        "PREC": 4,
        "OFF": 8,
        "HVEL": 8,
        "INIT": 4,
    }
    value = {
        "P": "ims:",
        "N": "",
        "M": '"m$(N)"',
        "DTYP": '"asynMotor"',
        "PORT": "IMS",
        "DESC": "",
        "ADDR": 0,
        "EGU": "mm",
        "DIR": "",
        "VELO": 0,
        "VBAS": 0,
        "ACCL": 0,
        "BDST": 0,
        "BVEL": 0,
        "BACC": 0,
        "DLLM": 0,
        "DHLM": 0,
        "MRES": 0,
        "PREC": 4,
        "OFF": 0,
        "HVEL": 0,
        "INIT": "",
        "DEV": "IMS",
        "AREA": "IOC",
        "LOC": 1,
        "TIMEOUT": 1,
    }
    motorValues = []
    for motor in motors:
        # pprint(motor)
        value["N"] = f'"{motor["devName"]}"'
        value["M"] = f'"{motor["name"]}"'
        value["PORT"] = "IMS" + motor["devName"]
        value["DESC"] = f'"{motor["cntrl"].split(":")[0]}.{motor["devName"]}"'  # quoted
        fieldWidth["DESC"] = max(len(value["DESC"]), fieldWidth["DESC"])
        value["EGU"] = motor.get("units", "mm")
        value["DIR"] = "Pos" if motor["sign"] > 0 else "Neg"
        value["VELO"] = motor["slew"] / motor["steps"]
        value["VBAS"] = motor["base"] / motor["steps"]
        value["ACCL"] = motor["accel"] * 1e-3
        value["BDST"] = motor["backl"] / motor["steps"]
        # No extra values for backlash velocity and acceleration are set in SPEC
        # therefore, use the values for forward operation
        value["BVEL"] = value["VELO"]
        value["BACC"] = value["ACCL"]
        value["DHLM"] = motor["upper_limit"]
        value["DLLM"] = motor["lower_limit"]
        value["MRES"] = 1 / motor["steps"]
        if "init_sequence" in motor:
            value["INIT"] = f'"{motor["init_sequence"]}"'
        value["OFF"] = motor["offset"]
        value["HVEL"] = value["VELO"] * 0.3 # third of normal speed for now
        motorValues.append(value.copy())

    def formatString(key, fieldWidth):
        """Formatting general (string) field width."""
        return "{" + key + ":>" + str(fieldWidth) + "}"

    def formatValue(width, val):
        """Format possible float values to fit into given field width."""
        if isinstance(val, float):
            return ("{0:." + str(width - 3) + "f}").format(val)
        else:
            return val

    def formatMotorParams(fieldWidth, motorValues):
        indent = "  "
        # format string of each row
        lineFormat = (
            "{{ " + ", ".join([formatString(key, fw) for key, fw in fieldWidth.items()]) + " }}"
        )
        # header with labels only
        body = [lineFormat.format(**dict(zip(fieldWidth.keys(), fieldWidth.keys())))]
        # format values of each motor
        for motorValue in motorValues:
            formatted = {
                key: formatValue(fieldWidth[key], val)
                for key, val in motorValue.items()
                if key in fieldWidth
            }
            body.append(lineFormat.format(**formatted))
        return "{\n" + f"{indent}pattern\n{indent}" + f"\n{indent}".join(body) + "\n}"

    basic_asyn_motor = formatMotorParams(fieldWidth, motorValues)
    # generate IMS_extra table
    fieldWidth = {
        "DEV": 3,
        "AREA": 4,
        "LOC": 3,
        "PORT": 4,
        "ADDR": 4,
        "TIMEOUT": 7,
    }
    ims_extra = formatMotorParams(fieldWidth, motorValues)
    return basic_asyn_motor, ims_extra


def getPortName(addressWithPort):
    host, port = addressWithPort.split(":")
    port = int(port, 0)
    portName = f"moxa{port%100}"
    return host, port, portName


def genIOCconfig(motorsByAddress: dict, imsPath: Path, outpath: Path):
    # pprint(motorsByAddress)
    outpath.mkdir(mode=0o755, exist_ok=True)
    # find IOC binary and other paths
    iocPath = imsPath / "iocs" / "imsIOC"
    binPath = list(iocPath.glob("**/bin/**/ims"))
    envPath = list(iocPath.glob("**/envPaths"))
    if not binPath or not binPath[0].is_file():
        raise RuntimeError(f"IOC binary could not be found within {imsPath}!")
    if not envPath or not envPath[0].is_file():
        raise RuntimeError(f"envPaths file could not be found within {imsPath}!")
    binPath = binPath[0].resolve()
    envPath = envPath[0].resolve()
    # read templates
    templateCmd = ""
    with open("cmd.template") as fd:
        templateCmd = fd.read()
    templateSubs = ""
    with open("substitutions.template") as fd:
        templateSubs = fd.read()
    # for testing
    # print("templateSubs:")
    # print(templateSubs)
    # print(f"{binPath=}")
    # print(f"{envPath=}")
    # find default motor record definition
    with open(envPath) as fd:
        motorPath = [line for line in fd.readlines() if "MOTOR" in line]
    # print(motorPath)
    if motorPath:
        motorPath = motorPath[0].split('"')[3]
    motorDbPath = Path(motorPath) / "db/basic_asyn_motor.db"
    # print(f"Found {motorDbPath=}", motorDbPath.is_file())
    # adjust motor record, add some fields
    with open(motorDbPath) as fd:
        motorDb = fd.readlines()
    idx = [i for i, line in enumerate(motorDb) if "field(INIT" in line]
    if idx:
        idx = idx[0]
        motorDb.insert(idx, "\tfield(HVEL,\"$(HVEL)\")\n")
        motorDb.insert(idx, "\tfield(OFF,\"$(OFF)\")\n")
    # pprint(motorDb)
    # write new motor record definition, path is reused in template later
    motorDbPathNew = (outpath / motorDbPath.name).resolve()
    # print("New motor db:", motorDbPathNew)
    motorDbPathNew.write_text("".join(motorDb))

    for addressWithPort, motors in motorsByAddress.items():
        _, port, portName = getPortName(addressWithPort)
        substitutionsPath = f"{portName}.substitutions"
        substitutionsPath = (outpath / f"{substitutionsPath}").resolve()
        cmdPath = (outpath / f"{portName}.cmd").resolve()
        # print(f'drvAsynIPPortConfigure("{portName}", "{addressWithPort}", 0, 0, 0 )')
        createController = []
        asynSetTraceIOMask = []
        asynSetTraceMask = []
        for motor in motors:
            dn = motor["devName"]
            motorPortName = f"IMS{dn}"
            createController.append(
                f'ImsMDrivePlusCreateController("{motorPortName}", "{portName}", "{dn}", 200, 5000)'
            )
            asynSetTraceIOMask.append(f'# asynSetTraceIOMask("{motorPortName}", 0, 0)')
            asynSetTraceMask.append(f'# asynSetTraceMask("{motorPortName}", 0, 9)')
        ImsMDrivePlusCreateController = "\n".join(createController)
        asynSetTraceIOMask = "\n".join(asynSetTraceIOMask)
        asynSetTraceMask = "\n".join(asynSetTraceMask)
        # print(ImsMDrivePlusCreateController)
        cmdContent = templateCmd.format(**locals())
        # write the file to disk
        with open(cmdPath, "w") as fd:
            fd.write(cmdContent)
        cmdPath.chmod(0o755)
        print(f"Wrote '{cmdPath.relative_to(Path().resolve())}'.")
        basic_asyn_motor, ims_extra = substitutions(motors)
        subsContent = templateSubs.format(**locals())
        # write the file to disk
        with open(substitutionsPath, "w") as fd:
            fd.write(subsContent)
        print(f"Wrote '{substitutionsPath.relative_to(Path().resolve())}'.")


def getDeviceNamesByAddress(addresses: dict, deviceNames: dict):
    deviceNamesByAddress = dict()
    for motName, addr in addresses.items():
        if addr not in deviceNamesByAddress:
            deviceNamesByAddress[addr] = []
        deviceNamesByAddress[addr].append(deviceNames[motName])
    return deviceNamesByAddress


def getMotorsByAddress(motors: List[dict]):
    motorsByAddress = dict()
    for motor in motors:
        addr = motor["address"]
        if addr not in motorsByAddress:
            motorsByAddress[addr] = []
        motorsByAddress[addr].append(motor)
    return motorsByAddress


def setEM(host, port, deviceName, value):
    import socket

    try:
        port = int(port, 0)
    except TypeError:
        pass
    print(f"Toggling Echo Mode (EM) for {deviceName} on {host}:{port}:")

    def send(sock, msg: str):
        sock.sendall(bytes(msg + "\n", "ascii"))

    def recv(sock):
        return str(sock.recv(128).strip(), "ascii")

    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
        # Connect to server and send data
        s.connect((host, port))
        send(s, f"{deviceName} PR EM")
        em = recv(s)
        print("Current Echo Mode:", em)
        emNew = max(1, min(2, value))
        print("Setting Echo Mode to", emNew, "...")
        send(s, f"{deviceName} EM {emNew}")  # does not return anything in EM=1
        send(s, f"{deviceName} PR EM")
        em = recv(s)
        if not em and emNew == 1:
            em = recv(s)  # try again
        print("New echo mode:", em)


def setEMbyPort(deviceNamesByAddress: dict, portOrName, value):
    host, port, deviceNames = None, None, []
    for addr, names in deviceNamesByAddress.items():
        host, port, portName = getPortName(addr)
        if str(port) == str(portOrName) or portName == str(portOrName):
            deviceNames = names
            break
    print(f"{deviceNames=}")
    if not deviceNames:
        raise ValueError(f"No devices found for given {portOrName=}!")
    for dn in deviceNames:
        setEM(host, port, dn, value)


def main(args: List[str] = None):
    """:param args: replaces sys.argv with a custom argument list."""
    args = configureParser().parse_args(args)
    print(args, args.mode)

    deviceNames, addresses = readAliasesAndAddresses(args.addressesAliases)
    print("SPEC motor names to device names map:")
    pprint(deviceNames)
    print("Addresses of motor device names:")
    pprint(addresses)

    if args.mode == "echomode":
        deviceNamesByAddress = getDeviceNamesByAddress(addresses, deviceNames)
        setEMbyPort(deviceNamesByAddress, args.port, args.value)
        return
    # elif args.mode == "generate":
    print("Limits of motors:")
    limits = readLimits(args.limits)
    pprint(limits)

    motors = motorsFromSPEC(args.configAdm, deviceNames, addresses, limits, filterCntrl="MDRIVE")
    convertValues(motors)
    print(f"Motor config for MDrives from SPEC ({len(motors)}):")
    # JSON output enriched motor params
    print(json.dumps(motors, indent=4))

    motors_selected = ("oldysam", "oldzsam")
    print(f"Motor config of {motors_selected} for EPICS substitutions file:")
    motors_selected = [motor for motor in motors if motor["name"] in motors_selected]
    basic_asyn_motor, ims_extra = substitutions(motors_selected)
    print(basic_asyn_motor)
    print(ims_extra)
    print("Generate and store IOC cmd file for each motor:")
    outpath = Path("generated")
    motorsByAddress = getMotorsByAddress(motors)
    genIOCconfig(motorsByAddress, args.imsPath, outpath)
    print("done.")


if __name__ == "__main__":
    main()
